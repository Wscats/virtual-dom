# htm模块

- [htm模块npm文档](https://www.npmjs.com/package/htm)

这段代码是一个用于构建 HTML 的 JavaScript 库的核心实现。它使用了一种类似于 JSX 的语法来编写 HTML，并提供了一些实用的函数来处理这些 HTML 结构。以下是代码的主要部分和功能：

1. **常量定义**:
   - `MODE_SLASH`, `MODE_TEXT`, `MODE_WHITESPACE`, `MODE_TAGNAME`, `MODE_COMMENT`, `MODE_PROP_SET`, `MODE_PROP_APPEND` 是一些用于表示解析状态的常量。
   - `CHILD_APPEND`, `CHILD_RECURSE`, `TAG_SET`, `PROPS_ASSIGN`, `PROP_SET`, `PROP_APPEND` 是一些用于表示操作类型的常量。

2. **`treeify` 函数**:
   - 这个函数接收一个由 `build` 函数生成的结构（通常是一个数组），并将其转换为一个更易于分析和转换的树形结构。
   - 它遍历输入的数组，根据不同的操作类型（如 `TAG_SET`, `PROPS_ASSIGN`, `PROP_SET`, `PROP_APPEND`, `CHILD_RECURSE`, `CHILD_APPEND`）构建一个嵌套的对象结构。

3. **`evaluate` 函数**:
   - 这个函数用于计算由 `build` 函数生成的结构的值。
   - 它遍历输入的数组，根据不同的操作类型执行相应的操作，如设置标签名、属性、子元素等。
   - 最终返回一个包含计算结果的数组。

4. **`build` 函数**:
   - 这是库的核心函数，用于解析和构建 HTML 结构。
   - 它接收一个模板字符串（通常包含 HTML 标签和 JavaScript 表达式）和一个包含表达式值的参数列表。
   - 函数首先初始化一些变量，如 `mode`（当前解析状态）、`buffer`（用于存储解析过程中的字符）、`quote`（用于存储当前解析的引号类型）和 `current`（用于存储当前解析的元素结构）。
   - 然后，它遍历模板字符串的每个字符，根据当前的解析状态和字符类型执行相应的操作。这些操作可能包括设置标签名、属性、子元素等。
   - 最后，函数返回构建好的 HTML 结构，通常是一个数组。

这段代码的主要目的是提供一种简洁、高效的方式来编写和处理 HTML。它允许开发者在 JavaScript 代码中使用类似于 JSX 的语法来编写 HTML，并在运行时动态地生成和更新这些 HTML 结构。这种方法可以提高代码的可读性和可维护性，同时提高性能。

`build` 函数是这段代码的核心，它负责将模板字符串（如 `<div>123</div>`）解析为一个内部表示的数据结构。以下是 `build` 函数如何解析模板字符串 `<div>123</div>` 的概述：

1. **初始化**:
   - `build` 函数首先初始化一些变量，如 `mode`（当前解析状态）、`buffer`（用于存储解析过程中的字符）、`quote`（用于存储当前解析的引号类型）和 `current`（用于存储当前解析的元素结构）。

2. **遍历模板字符串**:
   - 函数遍历模板字符串的每个字符，根据当前的解析状态和字符类型执行相应的操作。

3. **解析开始标签**:
   - 当遇到 `<` 字符时，`mode` 被设置为 `MODE_TAGNAME`，表示开始解析标签名。
   - 接下来的字符（`div`）被添加到 `buffer` 中。
   - 当遇到 `>` 字符时，`buffer` 中的内容（`div`）被用作标签名，并且一个新的元素结构被创建，其中包含标签名 `div`。

4. **解析文本内容**:
   - 遇到文本内容（`123`）时，`mode` 被设置为 `MODE_TEXT`。
   - 文本内容被添加到当前元素结构的子元素列表中。

5. **解析结束标签**:
   - 当遇到 `</` 字符时，`mode` 被设置为 `MODE_SLASH`，表示开始解析结束标签。
   - 接下来的字符（`div`）被添加到 `buffer` 中。
   - 当遇到 `>` 字符时，`buffer` 中的内容（`div`）被用作结束标签名，以验证它是否与开始标签名匹配。
   - 如果匹配，则表示元素解析完成，`current` 被设置为其父元素。

6. **返回结果**:
   - 函数返回构建好的 HTML 结构，通常是一个数组。

通过这个过程，`build` 函数将模板字符串 `<div>123</div>` 解析为一个内部表示的数据结构，该结构包含标签名、属性和子元素等信息。这个数据结构可以进一步被 `treeify` 函数转换为树形结构，或者被 `evaluate` 函数用于计算最终的 HTML 字符串。



`build` 函数用于解析模板字符串，并返回一个操作列表，该列表描述了如何使用提供的 `h` 函数（通常是一个用于创建虚拟 DOM 节点的函数）来构建相应的虚拟 DOM 树。在这个例子中，我们将解析 `<div href="">123</div>`。

首先，我们需要注意的是，`build` 函数的行为可能会受到 `MINI` 常量的值的影响。在这个解释中，我们假设 `MINI` 为 `false`，因为这样可以使输出更易于理解。

当我们调用 `build` 函数并传入模板字符串 `<div href="">123</div>` 时，`build` 函数会按照以下步骤执行：

1. 初始化一个名为 `current` 的数组，其初始值为 `[0]`。这个数组将用于存储操作列表。
2. 遍历模板字符串中的每个字符。
3. 根据当前的解析模式（由变量 `mode` 控制），对字符进行相应的处理。例如，如果当前模式是 `MODE_TAGNAME`，则会将字符添加到缓冲区 `buffer` 中，直到遇到一个空白字符或者 `>`。
4. 当遇到 `>` 时，会提交缓冲区中的内容，并根据当前模式执行相应的操作。例如，如果当前模式是 `MODE_TAGNAME`，则会将缓冲区中的内容（即标签名）添加到操作列表中。
5. 对于文本内容（如 `123`），会将其添加到操作列表中，并使用 `CHILD_APPEND` 操作码表示这是一个文本节点。
6. 当遇到 `</div>` 时，会提交缓冲区中的内容，并将当前节点设置为其父节点。

根据这些步骤，`build` 函数解析 `<div href="">123</div>` 后得出的 `current` 数组结构如下：

```javascript
[
  0, // 动态性标志位
  "div", // 标签名
  { href: "" }, // 属性对象
  "123" // 文本内容
]
```

这个数组表示了一个虚拟 DOM 节点，其标签名为 `div`，属性为 `href=""`，文本内容为 `123`。注意，这里的 `0` 是一个动态性标志位，表示该节点及其子节点是否依赖于动态值。在这个例子中，由于没有动态值，标志位为 `0`。

要使用这个操作列表构建虚拟 DOM 树，可以使用 `evaluate` 函数。例如：

```javascript
const h = (tag, props, children) => ({ tag, props, children });
const built = build`<div href="">123</div>`;
const vdom = evaluate(h, built, [], []);
```

这将返回一个表示虚拟 DOM 树的对象，其结构如下：

```javascript
{
  tag: "div",
  props: { href: "" },
  children: ["123"]
}
```

这个对象可以进一步处理，例如通过一个虚拟 DOM 库（如 React 或 Preact）渲染到实际的 DOM 中。
