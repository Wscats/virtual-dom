<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError(
                "Super expression must either be null or a function, not " + typeof superClass);
            // superClass && superClass.prototype如果有superClass并且有prototype，则取superClass.prototype
            // Object.create(null) 创建的对象是一个空对象
            // 往subClass的原型链继承superClass原型链的方法，并更改原型的构造函数为subClass
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            });
            // 讲道理，上面那一步已经是成功继承了，没有这一步也可以
            // setPrototypeOf会把对象的属性值继承到原型链上
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ =
                superClass;
        }

        function WeElement() {}
        // 这里的顺序注意一下，先执行_inherits方法然后再prototype上面挂载方法，如果顺序不对的话，那么prototype上的方法将会被_inherits方法覆盖
        _inherits(WeElement, HTMLElement);
        WeElement.prototype.connectedCallback = () => {}
        WeElement.prototype.disconnectedCallback = function () {}
        WeElement.prototype.update = function () {}
        WeElement.prototype.fire = function (name, data) {}
        // console.log(HTMLElement.prototype);
        console.log(new WeElement);

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }

        _classCallCheck(new WeElement, WeElement)
        _classCallCheck(new WeElement, WeElement)
        console.log(new WeElement instanceof WeElement) // true

        // 用法1
        // 判断 foo 是否是 Foo 类的实例
        // function Foo(){} 
        // var foo = new Foo(); 
        // console.log(foo instanceof Foo)//true

        // 用法2
        // instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型
        // var oStringObject = new String("hello world"); 
        // console.log(oStringObject instanceof String);   // 输出 "true"

    </script>
</body>

</html>